---
jupytext:
  formats: ipynb,md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.0
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

# Lab Week 3

## EOSC 211

### Learning Objectives:

1. Take a real world problem in EOAS and think of it like a scientific programmer
2. Apply our knowledge of *Python* data types, indexing, slicing arrays
3. Use built in functions and imported packages
4. Generate a scientific figure with Matplotlib
5. Reverse-engineer someone else's code to make it work for you

### Intro

In this lab we will apply our knowledge of *numpy arrays* to work with some real oceanographic data, as well as  generate a *scientific figure* using Python's *Matplotlib* library. Presenting your data with clear, concise, visually appealing figures is an exercise we will continually re-visit in this course, and will prove to be a useful skill throughout your career in EOAS. Below is a handy guide for creating excellent figures.

<div class="alert alert-block alert-info">
<b>Scientific Figure Checklist:</b> 

- [ ] Title (Short and sweet is best)
- [ ] Axes labels with units (Don't forget the units!)
- [ ] Legend (Or anything that helps interpret the information presented)
- [ ] Does the figure *make sense* just by looking at it? The data should be clear without referencing anything outside the figure
- [ ] Does it *look good*? (Do the colors clash? does it look crowded/messy?)
</div>

This lab is comprised of two sections: **1)** a tutorial for processing data with Python, Jupyter Notebooks, and creating a scientific figure with Matplotlib, and **2)** a set of instructions for creating your own figure which you will hand in. It is highly recommended that you work through the tutorial **before** attempting the assignment, as it covers a few concepts we have not specifically addressed in lecture yet, and which are essential for earning full marks on the lab assignment.

+++

## Section 1: Plot West Coast Bathymetry Data

In this tutorial, we will import a dataset as a *numpy* array and plot it using *matplotlib.* To keep things neat and organized, we will break the process down into the following steps:

1) Import required packages

2) Import raw data

3) Process the data

4) Display our results


### 1) Import Packages

It's good practice to import all the packages you'll need (on top of Python's core *built-in functions*) in a cell near the top of your notebook. So far we know we will be dealing with *numpy arrays* and making plots, so lets import Numpy and Matplotlib. There are a few different syntaxes for importing packages, demonstrated below:

```{code-cell} ipython3
import e211 # get all the packages from the e211 library (developed specifically for this course)
import numpy as np # get all the packages associated with numpy, and assign numpy a nickname 'np'
import matplotlib.pyplot as plt # get just the package called 'pyplot' from the matplotlib library, nicknamed 'plt'
```

These are all the dependencies we will need to complete this lab. If we decide later that we want to use something else, we can always add to this cell and re-run it.  

###  2) Import Raw Data

The data we wish to analyze is ```Bathyfile.mat```. *Bathymetry* refers to information about the depth of the ocean and the height of landmasses. The next thing to notice is that the file ends with `.mat`, which is the file extension used with data generated by MATLAB. To read this file into a jupyter notebook, we can use the built-in function `e211.load_mat()`. This function reads a `.mat` file and converts it into a numpy array. Similar functions exist for other data types like `.csv` (often used for spreadsheets), `.png` for images, `netCDF` files (outputs of climate models), `.shp/.shx/.dbf` (used for geographical information systems for programs like arcGIS).

```{code-cell} ipython3
raw_bathdata = e211.load_mat("Bathyfile.mat")

# what is the data type of the new variable we just created?
type(raw_bathdata)
```

Now that we have the data in a format we can use, let's explore! We can use built in functions to find out more things than just the data type:

```{code-cell} ipython3
np.shape(raw_bathdata)  # how big is the array?
```

```{code-cell} ipython3
np.min(raw_bathdata)  # what is the deepest point? (units are in m above/below sea level)
```

Let's make a "quick and dirty" plot as a preliminary way to visualize our data (especially since we changed the format, it is a good idea to check if anything went awry). This is just a quick check, we will worry about making it into a proper scientific figure later on. Since this is a 2D dataset (look at the cell where we found *np.shape* of the data), we can use the `contourf()` function from matplotlib.

```{code-cell} ipython3
plt.contourf(raw_bathdata);
```

We have successfully imported the .mat data as an array, but something is clearly wrong. This is supposed to be geographical information of BC and the Pacific Ocean. Can you recognize Vancouver Island? the Gulf of Alaska? The Rocky Mountains? What has happened here and how might we fix it?

### Process The Data

This step is also commonly referred to as "data scrubbing," and is often the longest step (about 80% of our time, according to [a source](https://www.datascienceatthecommandline.com/1e/chapter-1-introduction.html)) while working with a dataset. At this stage we can change the format, get rid of erroneous or extraneous data, combine/compare datasets, add labels to things, but it is important not to *alter* our data in a way that will compromise its *integrity*, which might lead us to make false conclusions from our information. 

First we need to flip our array over. We can do this using our knowledge of array slicing! Remember, the syntax for accessing elements in an array is `[start:stop:step]`.

```{code-cell} ipython3
bathdata_fixed = raw_bathdata[::-1]# flip the array over and assign it to a new variable
plt.contourf(bathdata_fixed); # try another quick visualization
```

Much better! Now let's think about generating a way to label our X and Y axes with something meaningful. Currently, the labels refer to the *array index* of each point on our plot. A far more useful reference would be the latitude (on the y axis) and longitude (on the x axis). This particular image is from latitude 47$^o$ to 60$^o$ N and longitude -150$^o$ to -110 $^o$E. The following code generates arrays that with the lat and lon of each row and column in the image, then passes those into the `contourf` function, which then creates the plot with the new labels applied. Take a second to understand what is happening at each line of code. You may want to try running in a cell `help()` with the name of a built-in function for more information on how that function works.

```{code-cell} ipython3
latlen = np.shape(bathdata_fixed)[0] # assign the height and width of the image to new vars
lonlen = np.shape(bathdata_fixed)[1]

lats = np.linspace(47, 60, latlen) # create arrays for lat and lon
lons = np.linspace(-150, -110, lonlen)

# plot it again!
plt.contourf(lons, lats, bathdata_fixed);
```

Maybe we are only interested in the bathymetry near Vancouver Island. We can "zoom" in on a particular area, using slicing to select a section of the original array. **IMPORTANT:** We need to slice the `lats` and `lons` arrays at the same intervals *before* we try to re-create the plot, or else we will get an error.

```{code-cell} ipython3
bath_zoomed = bathdata_fixed[0:150,500:900]
lats_zoomed = lats[0:150]
lons_zoomed = lons[500:900] # make sure the slices match between the
                            # coordinates and the original data

plt.contourf(lons_zoomed, lats_zoomed, bath_zoomed);
```

### Display the Results

If we are satisfied with our data processing, it is now time to present our result with a scientific figure. Go through the checklist and add code to our plot until we tick all of the boxes.

```{code-cell} ipython3
# change the colormap to something suitable
con = plt.contourf(lons_zoomed, lats_zoomed, bath_zoomed, cmap="terrain")

# add nice labels
plt.title("Bathymetry Near Vancouver Island")
plt.xlabel("longitude (deg)")
plt.ylabel("latitude (deg)")

# create a colorbar with labels to show the numerical values corresponding to each color
plt.colorbar(con, label="Height Above/Below Sea Level (m)");
```

Go through our checklist:
    
- [x] Title 
- [x] Axes labels with units
- [x] Legend - yes, the colorbar is similar to a legend, and we included units!
- [x] Does the figure *make sense* just by looking at it? - look at the colormap we chose: dark blue maps to deep ocean, white for snowy mountains. this makes the figure *visually intuitive*
- [x] Does it *look good*? - beauty is in the eye of the beholder, but I think it looks great

For changing the colormap, check out the [Matplotlib Documentation](https://matplotlib.org/stable/gallery/color/colormap_reference.html) for a list to choose from. Try inserting the names of other colormaps in place of "terrain" and see what happens. Note you can add "_r" to the end of any of colormap name to reverse it. 

Finally, as a last step, restart the kernel and re-run the whole notebook to check for errors (click the $\blacktriangleright\blacktriangleright$ button on the toolbar). This is important, so that the next time you run your notebook (or someone else, perhaps the person marking it), you know you will get the same result that you have now.

+++

## Section 2: Mapping Chlorophyl in the Ocean

In the `/lab_week3` folder, there is a dataset called `chlorophyl_apr2021.png`, which shows the concentration of chlorophyll (mg/m$^3$) in the ocean from satellite imagery, averaged over the month of April in 2021. The data originally came from 
NASA's Earth Observing System Data and Information System (EOSDIS), which can be found at [this website](https://oceancolor.gsfc.nasa.gov/).
 Your task is to go through much the same analysis as we did in the tutorial: import data into a Jupyter Notebook, scrub it, and use it to generate a scientific figure.


### To be handed in:

1) If you haven't already, open this notebook on Jupyterhub (press the rocketship button). Make sure to periodically save your work on and *back it up in at least two places* (your computer, google drive, dropbox, as well as jupyterhub)

2) Import the dataset as a numpy array. In the `e211` library, there is a function called `e211.load_oceancolor()` which will likely prove useful.

3) Scrub your dataset, correcting any errors and adding an appropriate coordinate system. (**Note**: on the whole globe, latitude runs from 90$^o$ (north pole) to -90 (south pole) with 0$^o$ at the equator and longitude from -180$^o$ to 180$^o$ with the 0$^o$ meridian passing through Greenwich, UK)

4) Zoom in on some place of interest. Where you go is totally up to you, but try to include a recognizable land feature in your plot.

5) Present your data, making sure to meet all the requirements for a scientific figure. Use a colormap other than the default.

6) Final check: run your whole notebook again and check for errors using the $\blacktriangleright\blacktriangleright$ button.

```{code-cell} ipython3
---
deletable: false
nbgrader:
  cell_type: code
  checksum: 6ade2630364eb95a2f48ecf62c401616
  grade: true
  grade_id: solution_cell
  locked: false
  points: 3
  schema_version: 3
  solution: true
  task: false
---
# your code here (create as many additional cells as you like)

# YOUR CODE HERE
raise NotImplementedError()
```
